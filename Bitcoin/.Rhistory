# the S&P500 data is read here and formatted
require(xts)
require(timeSeries)
require(Quandl)
stock=Quandl("CHRIS/CME_SP1", start_date="2011-09-18")
stock=as.xts(as.numeric(stock$Last), order.by=as.Date(stock$Date))
stock=stock[complete.cases(stock)]
weeklystock = apply.weekly(stock, mean)
URL = "http://api.bitcoincharts.com/v1/csv/bitstampUSD.csv.gz"
dir.create("data")
download.file(URL, destfile = "./data/bitcoin.csv")
# This part formats the bitcoin data, converts the Unix time to yyyy-mm-dd format
raw = read.csv("./data/bitcoin.csv", header=FALSE)
names(raw)=c("unixtime", "price", "amount")
raw$date <- as.Date(as.POSIXct(raw$unixtime, origin="1970-01-01"))
# All the transcation is shown when the data is downloaded,
# but we only need the average daily price, here the data is aggregated
raw = aggregate(price~date, data=raw, FUN = mean)
#The Bitcoin price data is changed to a weekly basis here.
data <- as.xts(raw$price,order.by=as.Date(raw$date))
weeklybitcoin <- apply.weekly(data,mean)
plot(weeklystock)
plot(weeklybitcoin)
#the two time series are trim to have the same length
weeklystock = weeklystock[(length(weeklystock)-length(weeklybitcoin)+1):length(weeklystock),]
weeklybitcoin=as.ts(weeklybitcoin)
weeklystock=as.ts(weeklystock)
#compute cross corelation of up to 20 lag
ccf(weeklybitcoin, weeklystock, lag.max = 20)
require(lmtest)
#weekly = weekly[(length(weekly)-length(result$trend$bitcoin.)+1):length(weekly)]
#test for Granger causality
test =  grangertest(weeklybitcoin~weeklystock , order=1)
test2 =  grangertest(weeklystock~weeklybitcoin , order=1)
bitcoints=ts(raw$price, start=c(2011.75), frequency =365.25)
plot.ts(bitcoints)
#HP decomposition of the Bitcoin data. A frequency of 100*365^2 is used
# for daily data
require(mFilter)
bitHP=hpfilter(bitcoints, freq = 100*365^2)
plot(bitHP$trend, ylab='Trend')
plot(bitHP$cycle, ylab='Cycle')
#Differencing the bitcoin data
require(forecast)
bitdif1=diff(bitcoints, differences = 1)
plot.ts(bitdif1, ylab='First_Difference')
#Second Difference the Bitcoin Data
bitdif2=diff(bitcoints, differences = 2)
plot.ts(bitdif2, ylab='Second_Difference')
# Find the ACF and PACF of the Bitcoin data
acf(bitdif1, main='First Difference')
pacf(bitdif1, main='First Difference')
#Cut the bitcion data to remove the bubble part
bitcoincut = window(bitcoints, c(2014.5), end(bitcoints))
plot.ts(bitcoincut)
#Difference the data again
bitcutdif1=diff(bitcoincut, differences = 1)
plot.ts(bitcutdif1, main="First Difference of Cut Series")
#Find ACF and PACF of the difference cut data
acf(bitcutdif1)
pacf(bitcutdif1)
#Find the confidence interval moving forward in Bitcoin price
arorder=auto.arima(bitcoincut, ic="bic")
bitcoinarima=arima(bitcoincut, order=c(2,1,1))
bitcoinforcast=forecast(bitcoinarima, h=180)
plot.forecast(bitcoinforcast)
#plot the second difference of the cut data
bitcutdif2=diff(bitcoincut, differences = 2)
plot.ts(bitcutdif2)
#Find the confidence interval moving forward in Bitcoin price
arorder=auto.arima(bitcoincut, ic="bic")
bitcoinarima=arima(bitcoincut, order=c(2,1,1))
bitcoinforcast=forecast(bitcoinarima, h=180)
plot.forecast(bitcoinforcast)
#Find the confidence interval moving forward in Bitcoin price
arorder=auto.arima(bitcoincut, ic="bic")
bitcoinarima=arima(bitcoincut, order=c(2,1,1))
bitcoinforcast=forecast(bitcoinarima, h=180)
plot(bitcoinforcast)
#predict the price of Bitcoin in 2016 using 2014 - 2015 data
bitcoinoneyear= window(bitcoincut, start(bitcoincut), c(2016))
bitcoinarima=arima(bitcoinoneyear, order=c(2,1,1))
bitcoinforcast=forecast(bitcoinarima, h=270)
# plots both forcast and the actually bitcoin price
plot.forecast(bitcoinforcast)
#predict the price of Bitcoin in 2016 using 2014 - 2015 data
bitcoinoneyear= window(bitcoincut, start(bitcoincut), c(2016))
bitcoinarima=arima(bitcoinoneyear, order=c(2,1,1))
bitcoinforcast=forecast(bitcoinarima, h=270)
# plots both forcast and the actually bitcoin price
plot(bitcoinforcast)
lines(bitcoincut)
